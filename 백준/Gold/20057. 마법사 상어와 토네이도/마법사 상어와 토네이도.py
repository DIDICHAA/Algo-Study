'''
1400 : 마법사 상어와 토네이도
[ 오늘의 문제 유의 포인트 ]
1. 문제 여러 번 읽기
2. 꼼꼼하게 설계하기 / 라인 바이 라인으로 바로 코드로 옮겨 적는다는 느낌
3. 무언가 이상할 때는 문제 다시 읽어보기 / 리프레쉬
4. 배열 돌리고 찍어보기

[ 주의할 점 ]
- 기존에 나와있는 모래 비율 + 좌표값은 모래 이동 방향에 따라 회전
- oob가 된 칸은 % 계산에서 제외, not oob 인 경우에만 % 별로 모래 날리고
    -> 그 나머지 %를 a의 위치에 넣어줘야 함
- 방향이 바뀌는 시점마다 (2번씩 이동한 뒤) % 배열도 해당 방향으로 돌려줘야 함
- 모래값은 int로 계산

1414 설계
1. 각 방향에 따라 % 배열을 돌리는 함수가 필요 // 총 세 개가 추가적으로 필요
2. 토네이도의 이동 방향은 '좌-하-우-상' 순서, n은 2번 이동할 때마다 1씩 늘어나고,
    -> 늘어난 n의 길이만큼 토네이도가 움직임
    for문 돌릴 때 cnt 같은 메서드로 체크해주고 cnt 초기화시켜주고 반복
3. % 배열은 어떻게 선언할 것??
    -> 기본형은 중간 좌표값을 중심으로 해서 각 칸의 % 모양이 달라짐
    그렇다면 배열이 아니라 현재 좌표값과 이동 좌표값을 기준으로, 8방의 %와
    각각의 oob 여부를 확인하는 함수가 필요함

!! 굳이 % 배열을 돌릴 필요가?
    -> 4방에 따른 y 기준 i, j, % 다 넣어놓고 direction에 따라 뽑아쓰면
        되는 거 아닌지?? 4개를 다 main에다가 정의해놓고 시작하는 거지

    rotate_map()
    % 배열을 방향에 맞게 돌려주는 함수
        - left, down, right, up
            -> 각각 따로 함수화 한 뒤, 리팩토링 시 합칠 수 있으면 합치기

    move_sand()
    dict[dir]에서 받아온 % 함수를 가지고 oob 체크,
    oob가 아니라면 y위치에 있는 모래 양을 % 만큼 날려줌
    해당 위치 += sand * x%
    sand -= 해당 위치
    a 위치 += sand

    if 현재 위치가 1,1이면 종료

    main
    입력값
    cnt = 0
    % 배열 선언 : (0, 1) 과 같은 dir 좌표값과 함께 %를 넣어줌 // 각 방향마다
    격자의 밖으로 나간 모래의 양 == 초기 모래의 양 -= 현재 남아있는 모래의 양

1433 구현 시작

1508 디버깅 시작
이슈1. 미묘하게 어긋나는 테케 답과, 테케 3부터는 어딘가에서 재귀에 빠짐
    -> 1) line by line으로 읽으면서 논리적으로 잘못됐거나, 빠트린 조건을 찾아보자!
        => 앗! 도는 거 n을 올려주는 위치와 수를 설정하지 않았다
        => dir 방향으로 1씩 2번, dir+1 방향으로 2씩 2번 ... 이렇게 가야 하는데
            지금은 그냥 전 방향을 두 번씩 가고 방향을 틀어버린다
            ?? n이 증가하는 부분을 어떻게 잡아줘야 하지?
            -> 방향 바꾼 횟수로 잡아줌
이슈2. 영원한 재귀에 빠져버림
    -> 내가 의도한 대로 함수 속 for문이 끝나지 않음 ㅠㅠ
         => n 더해주는 위치와 초기화 위치 재설정

이슈3. si, sj 좌표 값이 이상한데서 끝나심
    -> ???? 왜 si는 1이고 sj만 0인데 while문을 탈출하시지???????
        => 1,0 에서 빠져나오는 이유 // 그 앞의 좌표를 가기 전에 def 속 while문이 종료됨

이슈4. 모래가 지금 너무 많이 날아가고 계시는 거 같아요 ;;
'''
def oob(i, j):
    return 0<=i<N and 0<=j<N

def move_sand(si, sj, dir, N):
    global cnt, total_sand
    # si, sj는 x에 해당하는 좌표값 dict에 각 방향에 맞는 이동 방향을 불러와서
    # ssi, ssj로 갱신해줄 것 // y에 해당하는 좌표
    while N > 0:
        # visited[si][sj] = 1
        now = 0
        percentage = dir_dict[dir]  # 현재 방향에 맞는 배열을 불러옴
        ti, tj = a_dict[dir]
        ssi, ssj = si+ti, sj+tj  # y위치

        if oob(ssi, ssj):
            now = tor[ssi][ssj]  # 현재 위치의 모래 양, 얘를 날려줄 거임
            tor[ssi][ssj] = 0

            tmp = 0
            for di, dj, perc in percentage:
                ni, nj = ssi+di, ssj+dj  # 모래가 흩날릴 위치셔요
                if oob(ni, nj):  # 만약 날리려는 위치가 범위 내에 있다면
                    ms = int(now * perc) # 이 녀석을 해당 위치에 넣어줄 거임
                    tor[ni][nj] += ms
                    tmp += ms
                elif not oob(ni, nj):
                    os = int(now*perc)
                    # total_sand += os
                    tmp += os

        # 이동한 모래들을 뺀 나머지를 a 자리에 넣어줄 거임
        now -= tmp
        # y위치에서 한 번 더 ti, tj 방향으로 이동한 a위치에 남은 거 넣어줌
        ai, aj = ssi+ti, ssj+tj
        if oob(ai, aj):
            tor[ai][aj] += now

        N -= 1
        si, sj = ssi, ssj  # 다음 턴을 위해 ... ;;
    cnt += 1
    return si, sj


N = int(input())
tor = [list(map(int, input().split())) for _ in range(N)]
visited = [[0]*N for _ in range(N)]
cnt = 0
# y기준 % 배열이 움직일 수 있는 방향 i, j, 해당하는 %
l_per = [(-2, 0, 0.02), (-1, 0, 0.07), (-1, 1, 0.01), (1, 1, 0.01), (2, 0, 0.02),
         (1, 0, 0.07), (1, -1, 0.1), (0, -2, 0.05), (-1, -1, 0.1)]
u_per = [(-2, 0, 0.05), (-1, 1, 0.1), (0, 2, 0.02), (0, 1, 0.07), (1, 1, 0.01),
         (1, -1, 0.01), (0, -2, 0.02), (0, -1, 0.07), (-1, -1, 0.1)]
d_per = [(-1, 1, 0.01), (0, 1, 0.07), (0, 2, 0.02), (1, 1, 0.1), (2, 0, 0.05),
         (1, -1, 0.1), (0, -2, 0.02), (0, -1, 0.07), (-1, -1, 0.01)]
r_per = [(-2, 0, 0.02), (-1, 0, 0.07), (-1, 1, 0.1), (0, 2, 0.05), (1, 1, 0.1),
         (2, 0, 0.02), (1, 0, 0.07), (1, -1, 0.01), (-1, -1, 0.01)]

dir_dict = {0:l_per, 1:d_per, 2:r_per, 3:u_per}
a_dict = {0:(0, -1), 1:(1, 0), 2:(0, 1), 3:(-1, 0)}

total_sand = 0
for lst in tor:
    total_sand += sum(lst)

si, sj = N//2, N//2
dir = 0
n = 1  # 처음에 길이 1만큼 움직이니까
num = N*2 - 1

total = 0
while num > 0:
    ci, cj = move_sand(si, sj, dir, n)

    si, sj = ci, cj

    if dir == 0: dir = 1
    elif dir == 1: dir = 2
    elif dir == 2: dir = 3
    else: dir = 0

    if cnt == 2:
        n += 1
        cnt = 0

    num -= 1

for lst in tor:
    total += sum(lst)
total_sand -= total

print(total_sand)